
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Example of Reactive Solution With Scalaz-stream. Part 1 - Keep On Moving</title>
  <meta name="author" content="Alex Golubev">

  
  <meta name="description" content="In this post I&rsquo;m going to solve a problem of traversing remote tree structure asynchronously using scala. Two approaches will be implemented. &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://agolubev.github.io/blog/2015/04/26/example-of-reactive-solution-with-scalaz-stream-part-1/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Keep On Moving" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-60692024-1', 'auto');
  ga('send', 'pageview');

</script>
</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Keep On Moving</a></h1>
  
    <h2>Push harder. Keep going.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="agolubev.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Example of Reactive Solution With Scalaz-stream. Part 1</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-26T14:16:38-04:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>26</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>2:16 pm</span></time>
        
           | <a href="#disqus_thread"
             data-disqus-identifier="http://agolubev.github.io">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><p>In this post I&rsquo;m going to solve a problem of traversing remote tree structure asynchronously using scala. Two approaches will be implemented. First solution will use <code>futures</code>, the second one will be based on event streams with help of <a href="https://github.com/scalaz/scalaz-stream">scalaz-stream</a> library. Both approaches will be reactive by some extent.<!-- more --></p>

<hr />

<p>Idea of reactive programming was expressed for the first time in 1997 in the paper Functional Reactive Animation by Conal Elliot and Paul Hudak. It&rsquo;s not a long ago actually. Still, since then we&rsquo;ve got several stable frameworks and libraries for programming in reactive way.
Few names come to mind right away: <a href="http://reactivex.io/">ReactiveX</a>, <a href="http://akka.io/">Akka</a>. <a href="https://github.com/scalaz/scalaz-stream">Scalaz-stream</a> is another one that&rsquo;s not so feature reach but is the closest to functional programming paradigm as was branched out from scalaz project. We&rsquo;ll start form pure scala solution and then solve the same problem with help of scalaz-stream. In the next post I&rsquo;m going to compare these two solutions in detail.</p>

<p>Let&rsquo;s start from a problem description. Need to design a tool that traverses tree structure on a remote service and gets data associated with leafs. This is formalization of the problem solved in <a href="https://github.com/agolubev/playinzoo">Playinzoo</a> plugin. Plugin starts with Play framework, reads through tree structures of remote Zookeeper and returns result as configurational attributes. Zookeeper has only commands to get data associated with a node and obtain list of children for specific node. We can expect that algorithm will be pretty much like dealing with tree structures. As we&rsquo;ll work with remote service and probably load configuration for several subtrees it would be good to get data in parallel. That&rsquo;s when the fun begins. With having multiple threads doing something asynchronously we need to avoid mutable state or synchronize access to this state.</p>

<p>Let&rsquo;s speculate on how to solve this. As the first step we can think about simplified problem without parallel loading, that is, no asynchronous calls. Naive approach in this case will be recursive iteration via tree model. We need to have function that does remote calls with error handling. Connection management (aka closing it at the right moment, timeouts) will be simple as well.</p>

<p>With asynchronous loading things become complicated. To manage set of threads we&rsquo;ll need a thread pool explicitly or implicitly. Another problem we need to think about is when we should stop waiting for tasks that are running. As algorithm will be recursive with unknown tree depth we should consider some monitoring functionality. The simplest way here will be: incrementing counter when task is starting and decrementing when it&rsquo;s returning result. When counter is zero it means that there is no tasks running and we can return a result. In addition we&rsquo;ll need some queue to store results of remote calls (like paths to children nodes) and collection to accumulate loaded data from leafs.</p>

<h3>First solution - pure scala</h3>

<p>Ok, let&rsquo;s stop talking and start some coding. First we should decide on data types we are going to use:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">type</span> <span class="kt">NodePath</span> <span class="o">=</span> <span class="nc">String</span>
</span><span class='line'><span class="k">type</span> <span class="kt">NodeData</span> <span class="o">=</span> <span class="nc">String</span>
</span><span class='line'><span class="k">type</span> <span class="kt">Node</span> <span class="o">=</span> <span class="o">(</span><span class="nc">List</span><span class="o">[</span><span class="kt">NodePath</span><span class="o">],</span><span class="nc">Option</span><span class="o">[</span><span class="kt">NodeData</span><span class="o">])</span>
</span></code></pre></td></tr></table></div></figure>


<p>Type <code>Node</code> contains information we get from remote service. This can be list of children or node data if it&rsquo;s a leaf.
With this defined we can implement method for loading node information from remote service asynchronously.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'>  <span class="k">def</span> <span class="n">loadNodeInfo</span><span class="o">(</span><span class="n">path</span><span class="k">:</span> <span class="kt">NodePath</span><span class="o">,</span> <span class="n">results</span><span class="k">:</span> <span class="kt">BlockingQueue</span><span class="o">[</span><span class="kt">Node</span><span class="o">])</span> <span class="k">=</span> <span class="n">future</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="n">node</span><span class="k">:</span><span class="kt">Node</span> <span class="o">=</span> <span class="o">???</span> <span class="c1">//request remote service: get children, if leaf - get data</span>
</span><span class='line'>    <span class="n">node</span>
</span><span class='line'>  <span class="o">}</span> <span class="n">onComplete</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">node</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">results</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">node</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">results</span><span class="o">.</span><span class="n">add</span><span class="o">((</span><span class="nc">Nil</span><span class="o">,</span><span class="nc">None</span><span class="o">))</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Function <code>loadNodeInfo</code> creates <code>future</code> as task to load data from service. When future is done, result will be added to the blocking queue. Now it&rsquo;s time to implement function that actually do the job of creating futures and processing node information.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">import</span> <span class="nn">java.util.concurrent.</span><span class="o">{</span><span class="nc">LinkedBlockingQueue</span><span class="o">,</span> <span class="nc">BlockingQueue</span><span class="o">,</span> <span class="nc">Executors</span><span class="o">}</span>
</span><span class='line'><span class="k">import</span> <span class="nn">java.util.concurrent.atomic.AtomicInteger</span>
</span><span class='line'><span class="k">import</span> <span class="nn">scala.concurrent._</span>
</span><span class='line'><span class="k">import</span> <span class="nn">scala.util.</span><span class="o">{</span><span class="nc">Failure</span><span class="o">,</span> <span class="nc">Success</span><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">implicit</span> <span class="k">val</span> <span class="n">ec</span> <span class="k">=</span> <span class="nc">ExecutionContext</span><span class="o">.</span><span class="n">fromExecutor</span><span class="o">(</span><span class="nc">Executors</span><span class="o">.</span><span class="n">newFixedThreadPool</span><span class="o">(</span><span class="mi">8</span><span class="o">))</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">loadFromZk</span><span class="o">(</span><span class="n">paths</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">NodePath</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">NodeData</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">//creating future as task to load data from Zk. When it&#39;s done - put the result into queue</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">loadNodeInfo</span><span class="o">(</span><span class="n">path</span><span class="k">:</span><span class="kt">NodePath</span><span class="o">,</span> <span class="n">results</span><span class="k">:</span> <span class="kt">BlockingQueue</span><span class="o">[</span><span class="kt">Node</span><span class="o">])</span> <span class="k">=</span> <span class="o">{...}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">//collection to accumulate loaded data</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">readProperties</span> <span class="k">=</span> <span class="nc">List</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">NodeData</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">//point of synchronization of loading tasks and monitor</span>
</span><span class='line'>  <span class="k">val</span> <span class="n">zkLoadedResults</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">LinkedBlockingQueue</span><span class="o">[</span><span class="kt">Node</span><span class="o">]()</span>
</span><span class='line'>  <span class="n">zkLoadedResults</span><span class="o">.</span><span class="n">add</span><span class="o">((</span><span class="n">paths</span><span class="o">,</span><span class="nc">None</span><span class="o">))</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">//counter for the running tasks</span>
</span><span class='line'>  <span class="k">val</span> <span class="n">runningTasksCounter</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">AtomicInteger</span><span class="o">(</span><span class="n">paths</span><span class="o">.</span><span class="n">size</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">var</span> <span class="n">node</span><span class="k">:</span><span class="kt">Node</span> <span class="o">=</span> <span class="kc">null</span>
</span><span class='line'>  <span class="c1">//this is where monitor logic is waiting for tasks result</span>
</span><span class='line'>  <span class="k">while</span> <span class="o">(</span> <span class="o">{</span> <span class="n">node</span> <span class="k">=</span> <span class="n">zkLoadedResults</span><span class="o">.</span><span class="n">take</span><span class="o">();</span> <span class="n">node</span> <span class="o">}</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">runningTasksCounter</span><span class="o">.</span><span class="n">decrementAndGet</span><span class="o">()</span>
</span><span class='line'>    <span class="k">for</span><span class="o">(</span><span class="n">path</span> <span class="k">&lt;-</span> <span class="n">node</span><span class="o">.</span><span class="n">_1</span><span class="o">){</span>
</span><span class='line'>      <span class="n">runningTasksCounter</span><span class="o">.</span><span class="n">incrementAndGet</span><span class="o">()</span>
</span><span class='line'>      <span class="n">loadNodeInfo</span><span class="o">(</span><span class="n">path</span><span class="o">,</span> <span class="n">zkLoadedResults</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">for</span><span class="o">(</span><span class="n">data</span> <span class="k">&lt;-</span> <span class="n">node</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span> <span class="n">readProperties</span> <span class="k">=</span> <span class="n">data</span> <span class="o">::</span> <span class="n">readProperties</span>
</span><span class='line'>    <span class="c1">//if counter is 0 we done</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">runningTasksCounter</span><span class="o">.</span><span class="n">get</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">readProperties</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="n">readProperties</span> <span class="c1">//actually we&#39;ll never rich this point</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Function <code>loadFromZk</code> which does the magic. It uses <code>zkLoadedResults</code> as a queue for <code>Node</code> information. Method pulls out the next result, creates load task for each received path and adds data to result list in case it&rsquo;s available. <code>runningTasksCounter</code> counts how many tasks are now running. Actually in real life some of them are running but others are waiting for a vacant thread in a pool.</p>

<p>Synchronization between main thread and tasks from pool is done with help of <code>BlockingQueue</code>. Potentially we can add timeout for getting the next result <code>zkLoadedResults.take()</code>. Please note that mutable state (mutable data structures and variables) localized in one method - <code>loadFromZk</code> so solution still can be considered as functional.</p>

<h3>Second solution - based on scalaz-stream</h3>

<p>Now let&rsquo;s try to solve the same problem with help of scalaz-stream library. We&rsquo;ll apply reactive approach to process remote service responses. In other words we&rsquo;ll implement event stream based on pull model. In this case we&rsquo;ll have following as events: node paths, node data, running task counter. As there is no much documentation for the library, we will look into second implementation in more detail. As first step  we will create stream with queue as a source.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">import</span> <span class="nn">scalaz.stream._</span>
</span><span class='line'><span class="k">import</span> <span class="nn">scalaz.</span><span class="o">\/.</span><span class="k">_</span>
</span><span class='line'><span class="k">import</span> <span class="nn">scalaz.</span><span class="o">\/</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="n">pathsQueue</span> <span class="k">=</span> <span class="n">async</span><span class="o">.</span><span class="n">unboundedQueue</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="c1">//creating queue</span>
</span><span class='line'><span class="k">val</span> <span class="n">queueStream</span><span class="k">:</span> <span class="kt">Process</span><span class="o">[</span><span class="kt">Task</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">pathsQueue</span><span class="o">.</span><span class="n">dequeue</span> <span class="c1">//creating stream</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="n">echoStream</span> <span class="k">=</span> <span class="n">queueStream</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="n">a</span><span class="o">);</span> <span class="n">a</span> <span class="o">})</span> <span class="c1">//print events </span>
</span><span class='line'><span class="nc">Task</span><span class="o">.</span><span class="n">fork</span><span class="o">(</span><span class="n">echoStream</span><span class="o">.</span><span class="n">runLog</span><span class="o">).</span><span class="n">runAsync</span><span class="o">(</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="o">()</span> <span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>You can try this on REPL and find out that the last command returns nothing. Actually, it runs stream in a separate thread waiting for new elements in <code>pathsQueue</code>. So if you type <code>pathsQueue.enqueueOne("/firstPath").run</code> in REPL you&rsquo;ll see <code>"/firstPath"</code> as output. Obviously, what we just saw was pulling nature of streams in reacting on some event.</p>

<p>So far so good. Let&rsquo;s add several transformations to the stream to call <code>loadNodeInfo</code> asynchronously and pass the result as event further down the stream. We are going to use the same <code>Node</code> type from the first implementation here as well.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">import</span> <span class="nn">scalaz.concurrent._</span>
</span><span class='line'><span class="k">import</span> <span class="nn">scalaz.stream._</span>
</span><span class='line'><span class="k">import</span> <span class="nn">scalaz.</span><span class="o">{\/-,</span> <span class="o">\/}</span>
</span><span class='line'><span class="c1">//the same data model</span>
</span><span class='line'><span class="k">type</span> <span class="kt">NodePath</span> <span class="o">=</span> <span class="nc">String</span>
</span><span class='line'><span class="k">type</span> <span class="kt">NodeData</span> <span class="o">=</span> <span class="nc">String</span>
</span><span class='line'><span class="k">type</span> <span class="kt">Node</span> <span class="o">=</span> <span class="o">(</span><span class="nc">List</span><span class="o">[</span><span class="kt">NodePath</span><span class="o">],</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">NodeData</span><span class="o">])</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="n">pathsQueue</span> <span class="k">=</span> <span class="n">async</span><span class="o">.</span><span class="n">unboundedQueue</span><span class="o">[</span><span class="kt">NodePath</span><span class="o">]</span>
</span><span class='line'><span class="k">val</span> <span class="n">loadingStream</span><span class="k">:</span> <span class="kt">Process</span><span class="o">[</span><span class="kt">Task</span>, <span class="kt">NodePath</span><span class="o">]</span> <span class="k">=</span> <span class="n">pathsQueue</span><span class="o">.</span><span class="n">dequeue</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">loadNodeInfo</span><span class="o">(</span><span class="n">path</span><span class="k">:</span> <span class="kt">NodePath</span><span class="o">)</span><span class="k">:</span> <span class="kt">Node</span> <span class="o">=</span> <span class="o">???</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="n">loadedData</span> <span class="k">=</span> <span class="n">loadingStream</span><span class="o">.</span><span class="n">flatMap</span><span class="o">[</span><span class="kt">Task</span>, <span class="kt">Node</span><span class="o">](</span><span class="n">x</span> <span class="k">=&gt;</span>
</span><span class='line'>  <span class="nc">Process</span><span class="o">.</span><span class="n">eval</span><span class="o">(</span><span class="nc">Task</span><span class="o">.</span><span class="n">async</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">cb</span><span class="k">:</span> <span class="o">((</span><span class="kt">Throwable</span> <span class="kt">\/</span> <span class="kt">Node</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="kt">Unit</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">cb</span><span class="o">(\/-(</span><span class="n">loadNodeInfo</span><span class="o">(</span><span class="n">x</span><span class="o">)))</span>
</span><span class='line'>  <span class="o">}))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Starting point for our stream as well as source for events is <code>pathsQueue</code>. It contains node paths as instructions to load children or data (if it&rsquo;s a leaf) from remote service. Queue can be updated asynchronously and for simplicity has no bounds. The line <code>Process.eval(Task.async{...})</code> wraps task into a stream, then it runs async task that will do callback <code>cb</code> as soon as result is ready.</p>

<p>As next step we need to accumulate some statistics along with <code>(List[NodePath], Option[NodeData])</code> to emulate <code>runningTasksCounter</code> for tasks running in parallel.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">dataAndStatistics</span> <span class="k">=</span>
</span><span class='line'>    <span class="n">loadedData</span><span class="o">.</span><span class="n">scan</span><span class="o">[(</span><span class="kt">List</span><span class="o">[</span><span class="kt">NodePath</span><span class="o">]</span>, <span class="kt">Option</span><span class="o">[</span><span class="kt">NodeData</span><span class="o">]</span>, <span class="kt">Int</span><span class="o">)]((</span><span class="nc">Nil</span><span class="o">,</span> <span class="nc">None</span><span class="o">,</span> <span class="n">initialNumberOfPaths</span><span class="o">))((</span><span class="n">a</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">val</span> <span class="n">stat</span> <span class="k">=</span> <span class="n">a</span><span class="o">.</span><span class="n">_3</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="n">_1</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span>
</span><span class='line'>  <span class="n">println</span><span class="o">(</span><span class="s">&quot;* Currently tasks in pool &quot;</span> <span class="o">+</span> <span class="n">stat</span><span class="o">)</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">stat</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">pathsQueue</span><span class="o">.</span><span class="n">close</span><span class="o">.</span><span class="n">run</span>
</span><span class='line'>  <span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="n">_1</span><span class="o">,</span> <span class="n">c</span><span class="o">.</span><span class="n">_2</span><span class="o">,</span> <span class="n">stat</span><span class="o">)</span>
</span><span class='line'><span class="o">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>Important line here is one that sends <code>close</code> event to queue <code>pathsQueue.close.run</code> to let all stream activities shut down normally with special <code>Complete</code> event.
For scan function <code>(a, r)</code> attributes are like for <code>foldLeft</code>. <code>a</code> is accumulated value, <code>c</code> is current pulled event.</p>

<p>At first I thought about splitting stream into two - one will be data oriented, another will gather statistics and shut down system. Unfortunately for now there is no such build-in function in scalaz-stream we can use. (In ReactiveX, for example, there is <code>groupBy</code> function that does what we want.)</p>

<p>Next we need to notify stream that there are other nodes to iterate. To do this we add new paths to the queue and return only <code>Option[NodeData]</code> as event for the next stream as we don&rsquo;t need anything else:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">nodeDataStream</span> <span class="k">=</span> <span class="n">dataAndStatistics</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="n">_1</span><span class="o">.</span><span class="n">nonEmpty</span><span class="o">)</span> <span class="n">pathsQueue</span><span class="o">.</span><span class="n">enqueueAll</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="n">_1</span><span class="o">).</span><span class="n">run</span>
</span><span class='line'>  <span class="n">a</span><span class="o">.</span><span class="n">_2</span>
</span><span class='line'><span class="o">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>Finally we filter out all events with no data and transform <code>Stream[Option[NodeData]]</code> to <code>Stream[NodeData]</code>. After this we get all data from stream by calling <code>runLog</code>. (Alternatively there are possibility to run <code>runLast</code> which returns only last event or <code>run</code> that returns <code>Unit</code>.) <code>runLog</code> function returns <code>Task</code> object. As soon as we are going to run the task synchronously and wait for the result we should call <code>runLog.run</code>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">pureNodeDataStream</span> <span class="k">=</span> <span class="n">nodeDataStream</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">isDefined</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">get</span><span class="o">)</span>
</span><span class='line'><span class="k">val</span> <span class="n">result</span><span class="k">:</span> <span class="kt">IndexedSeq</span><span class="o">[</span><span class="kt">NodeData</span><span class="o">]</span> <span class="k">=</span> <span class="n">pureNodeDataStream</span><span class="o">.</span><span class="n">runLog</span><span class="o">.</span><span class="n">run</span>
</span></code></pre></td></tr></table></div></figure>


<p>Cool! Let&rsquo;s now add some code to emulate remote call with few seconds delay and add some output to verify asynchronous loading:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">loadNodeInfo</span><span class="o">(</span><span class="n">path</span><span class="k">:</span> <span class="kt">NodePath</span><span class="o">)</span><span class="k">:</span> <span class="kt">Node</span> <span class="o">=</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">println</span><span class="o">(</span><span class="s">&quot;&gt; Request info for node &quot;</span> <span class="o">+</span> <span class="n">path</span> <span class="o">+</span> <span class="s">&quot; at &quot;</span> <span class="o">+</span> <span class="nc">Thread</span><span class="o">.</span><span class="n">currentThread</span><span class="o">().</span><span class="n">getName</span><span class="o">)</span>
</span><span class='line'>  <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">2000</span><span class="o">)</span>
</span><span class='line'>  <span class="n">println</span><span class="o">(</span><span class="s">&quot;&lt; Received response for node &quot;</span> <span class="o">+</span> <span class="n">path</span> <span class="o">+</span> <span class="s">&quot; at &quot;</span> <span class="o">+</span> <span class="nc">Thread</span><span class="o">.</span><span class="n">currentThread</span><span class="o">().</span><span class="n">getName</span><span class="o">)</span>
</span><span class='line'>  <span class="k">val</span> <span class="n">depth</span> <span class="k">=</span> <span class="n">path</span><span class="o">.</span><span class="n">count</span><span class="o">(</span><span class="k">_</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span><span class="o">)</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">depth</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">)</span>
</span><span class='line'>    <span class="o">(</span><span class="n">path</span> <span class="o">+</span> <span class="s">&quot;/node&quot;</span> <span class="o">+</span> <span class="n">depth</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">,</span> <span class="nc">None</span><span class="o">)</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>    <span class="o">(</span><span class="nc">Nil</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="s">&quot;Data for &quot;</span> <span class="o">+</span> <span class="n">path</span><span class="o">))</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="n">paths</span> <span class="k">=</span> <span class="s">&quot;/first&quot;</span> <span class="o">::</span> <span class="s">&quot;/second&quot;</span> <span class="o">::</span> <span class="nc">Nil</span>
</span><span class='line'><span class="n">pathsQueue</span><span class="o">.</span><span class="n">enqueueAll</span><span class="o">(</span><span class="n">paths</span><span class="o">).</span><span class="n">run</span> <span class="c1">//enqueue paths for root node. enqueueAll returns task so need to call run</span>
</span><span class='line'><span class="k">val</span> <span class="n">initialNumberOfPaths</span> <span class="k">=</span> <span class="n">paths</span><span class="o">.</span><span class="n">size</span>
</span></code></pre></td></tr></table></div></figure>


<p>Function <code>loadNodeInfo</code> emulates request/response to quite slow Zookeeper service. It emulates tree structure as simple chain with 2 folder nodes and data node at the end. The code snippet also adds two paths to queue <code>/first</code> and <code>/second</code> to iterate though these two subtrees.</p>

<p>When we run <a href="https://gist.github.com/agolubev/13bc4c1bc865de97f64c">full code example</a> in REPL we&rsquo;ll see that <code>loadNodeInfo</code> calls are still not running in parallel:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>&gt; Request info <span class="k">for</span> node /first at pool-1-thread-4
</span><span class='line'>&lt; Received response <span class="k">for</span> node /first at pool-1-thread-4
</span><span class='line'>* Currently tasks in pool 2
</span><span class='line'>&gt; Request info <span class="k">for</span> node /second at pool-1-thread-5
</span><span class='line'>&lt; Received response <span class="k">for</span> node /second at pool-1-thread-5
</span><span class='line'>* Currently tasks in pool 2
</span><span class='line'>&gt; Request info <span class="k">for</span> node /first/node1 at pool-1-thread-1
</span><span class='line'>&lt; Received response <span class="k">for</span> node /first/node1 at pool-1-thread-1
</span><span class='line'>* Currently tasks in pool 2
</span><span class='line'>&gt; Request info <span class="k">for</span> node /second/node1 at pool-1-thread-7
</span><span class='line'>&lt; Received response <span class="k">for</span> node /second/node1 at pool-1-thread-7
</span><span class='line'>* Currently tasks in pool 2
</span><span class='line'>&gt; Request info <span class="k">for</span> node /first/node1/node2 at pool-1-thread-1
</span><span class='line'>&lt; Received response <span class="k">for</span> node /first/node1/node2 at pool-1-thread-1
</span><span class='line'>* Currently tasks in pool 1
</span><span class='line'>&gt; Request info <span class="k">for</span> node /second/node1/node2 at pool-1-thread-3
</span><span class='line'>&lt; Received response <span class="k">for</span> node /second/node1/node2 at pool-1-thread-3
</span><span class='line'>* Currently tasks in pool 0
</span><span class='line'>resultStream: IndexedSeq<span class="o">[</span>String<span class="o">]</span> <span class="o">=</span> Vector<span class="o">(</span>Data <span class="k">for</span> /first/node1/node2, Data <span class="k">for</span> /second/node1/node2<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>We can fix this by create Stream of Streams during <code>loadingStream</code> transformation and using <code>nondeterminism.njoin</code> to merge and send results as events to one stream.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">loadedData</span> <span class="k">=</span> <span class="n">nondeterminism</span><span class="o">.</span><span class="n">njoin</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">1</span><span class="o">)(</span><span class="n">loadingStream</span><span class="o">.</span><span class="n">map</span><span class="o">[</span><span class="kt">Process</span><span class="o">[</span><span class="kt">Task</span>, <span class="kt">Node</span><span class="o">]](</span><span class="n">x</span> <span class="k">=&gt;</span>
</span><span class='line'>  <span class="nc">Process</span><span class="o">.</span><span class="n">eval</span><span class="o">(</span><span class="nc">Task</span><span class="o">.</span><span class="n">async</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">cb</span><span class="k">:</span> <span class="o">((</span><span class="kt">Throwable</span> <span class="kt">\/</span> <span class="kt">Node</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="kt">Unit</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">cb</span><span class="o">(\/-(</span><span class="n">loadNodeInfo</span><span class="o">(</span><span class="n">x</span><span class="o">)))</span>
</span><span class='line'>  <span class="o">})))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Few words about magic numbers in njoin call: 10 is pool capacity and 1 is queue length for all tasks running in the pool. You can find final code <a href="https://gist.github.com/agolubev/0c2430c750eaa4096436">here</a>. When we run it we get the correct result:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>&gt; Request info <span class="k">for</span> node /first at pool-1-thread-2
</span><span class='line'>&gt; Request info <span class="k">for</span> node /second at pool-1-thread-5
</span><span class='line'>&lt; Received response <span class="k">for</span> node /first at pool-1-thread-2
</span><span class='line'>&lt; Received response <span class="k">for</span> node /second at pool-1-thread-5
</span><span class='line'>* Currently tasks in pool 2
</span><span class='line'>* Currently tasks in pool 2
</span><span class='line'>&gt; Request info <span class="k">for</span> node /first/node1 at pool-1-thread-1
</span><span class='line'>&gt; Request info <span class="k">for</span> node /second/node1 at pool-1-thread-6
</span><span class='line'>&lt; Received response <span class="k">for</span> node /first/node1 at pool-1-thread-1
</span><span class='line'>* Currently tasks in pool 2
</span><span class='line'>&gt; Request info <span class="k">for</span> node /first/node1/node2 at pool-1-thread-4
</span><span class='line'>&lt; Received response <span class="k">for</span> node /second/node1 at pool-1-thread-6
</span><span class='line'>* Currently tasks in pool 2
</span><span class='line'>&gt; Request info <span class="k">for</span> node /second/node1/node2 at pool-1-thread-5
</span><span class='line'>&lt; Received response <span class="k">for</span> node /first/node1/node2 at pool-1-thread-4
</span><span class='line'>* Currently tasks in pool 1
</span><span class='line'>&lt; Received response <span class="k">for</span> node /second/node1/node2 at pool-1-thread-5
</span><span class='line'>* Currently tasks in pool 0
</span><span class='line'>resultStream: IndexedSeq<span class="o">[</span>String<span class="o">]</span> <span class="o">=</span> Vector<span class="o">(</span>Data <span class="k">for</span> /first/node1/node2, Data <span class="k">for</span> /second/node1/node2<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Finally we can see that requests are running in parallel, independently on each other. Consequently, as a result we got functional solution for our tree traversal problem that based on streams and is reactive by it&rsquo;s nature.</p>

<p>As summary I&rsquo;ll provide the list of links I found for getting into reactive programming and scalaz-stream:</p>

<ul>
<li>A list of good articles is available right on streaz-scala project on <a href="https://github.com/scalaz/scalaz-stream/wiki/Additional-Resources">Additional resources</a> page;</li>
<li>When you&rsquo;re dealing with scalaz streams it&rsquo;s essential to understand scalaz type - Task. So you should look for short <a href="http://timperrett.com/2014/07/20/scalaz-task-the-missing-documentation/">tutorial</a> about Task as well;</li>
<li>Also there is a presentation with overview of scalaz-stream functions <a href="http://pchiusano.github.io/talks/scalaz-stream-nescala-2014/scalaz-stream-nescala-2014.html">available here</a>;</li>
<li>And of course Coursera lectures <a href="https://class.coursera.org/reactive-002">Principles of Reactive Programming</a> that give outstanding vision on this topic.</li>
</ul>

</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Alex Golubev</span></span>

      




<time class='entry-date' datetime='2015-04-26T14:16:38-04:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>26</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>2:16 pm</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/reactive/'>reactive</a>, <a class='category' href='/blog/categories/scala/'>scala</a>, <a class='category' href='/blog/categories/scalaz-stream/'>scalaz-stream</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://agolubev.github.io/blog/2015/04/26/example-of-reactive-solution-with-scalaz-stream-part-1/" data-via="" data-counturl="http://agolubev.github.io/blog/2015/04/26/example-of-reactive-solution-with-scalaz-stream-part-1/" >Tweet</a>
  
  
  
    <div class="fb-like" data-send="true" data-width="450" data-show-faces="false"></div>
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/03/07/zookeeper-configuration-storage-for-play-applications/" title="Previous Post: Zookeeper - configuration storage for Play applications">&laquo; Zookeeper - configuration storage for Play applications</a>
      
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/04/26/example-of-reactive-solution-with-scalaz-stream-part-1/">Example of Reactive Solution With Scalaz-stream. Part 1</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/03/07/zookeeper-configuration-storage-for-play-applications/">Zookeeper - Configuration Storage for Play Applications</a>
      </li>
    
  </ul>
</section>




  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Alex Golubev -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'agolubevgithubio';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://agolubev.github.io/blog/2015/04/26/example-of-reactive-solution-with-scalaz-stream-part-1/';
        var disqus_url = 'http://agolubev.github.io/blog/2015/04/26/example-of-reactive-solution-with-scalaz-stream-part-1/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id; js.async = true;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>





  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
